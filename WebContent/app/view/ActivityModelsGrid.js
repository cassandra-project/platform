/*
 * File: app/view/ActivityModelsGrid.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.0.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('C.view.ActivityModelsGrid', {
	extend: 'Ext.grid.Panel',

	height: 250,
	width: 400,
	closable: true,
	title: 'My Grid Panel',
	forceFit: false,
	store: 'ActivityModels',

	initComponent: function() {
		var me = this;

		Ext.applyIf(me, {
			viewConfig: {
				plugins: [
					Ext.create('Ext.grid.plugin.DragDrop', {
						ptype: 'gridviewdragdrop',
						ddGroup: 'ddGlobal'
					})
				],
				listeners: {
					selectionchange: {
						fn: me.onGridviewSelectionChange,
						scope: me
					},
					beforedrop: {
						fn: me.onGriddragdroppluginBeforeDrop,
						scope: me
					},
					drop: {
						fn: me.onGriddragdroppluginDrop,
						scope: me
					}
				}
			},
			columns: [
				{
					xtype: 'gridcolumn',
					dataIndex: '_id',
					text: '_id'
				},
				{
					xtype: 'gridcolumn',
					dataIndex: 'name',
					text: 'Name',
					editor: {
						xtype: 'textfield'
					}
				},
				{
					xtype: 'gridcolumn',
					dataIndex: 'type',
					text: 'Type',
					editor: {
						xtype: 'textfield'
					}
				},
				{
					xtype: 'gridcolumn',
					dataIndex: 'description',
					text: 'Description',
					editor: {
						xtype: 'textfield'
					}
				},
				{
					xtype: 'booleancolumn',
					dataIndex: 'shiftable',
					text: 'Shiftable'
				},
				{
					xtype: 'gridcolumn',
					dataIndex: 'day_type',
					text: 'Day Type'
				},
				{
					xtype: 'gridcolumn',
					dataIndex: 'act_id',
					text: 'Activity_id'
				},
				{
					xtype: 'gridcolumn',
					hidden: true,
					dataIndex: 'containsAppliances',
					text: 'Contains Appliances'
				},
				{
					xtype: 'gridcolumn',
					dataIndex: 'duration',
					text: 'Duration',
					editor: {
						xtype: 'textfield'
					}
				},
				{
					xtype: 'gridcolumn',
					dataIndex: 'startTime',
					text: 'Start Time',
					editor: {
						xtype: 'textfield'
					}
				},
				{
					xtype: 'gridcolumn',
					dataIndex: 'repeatsNrOfTime',
					text: 'Repeats Nr of Times',
					editor: {
						xtype: 'textfield'
					}
				}
			],
			selModel: Ext.create('Ext.selection.RowModel', {
				mode: 'MULTI'
			}),
			dockedItems: [
				{
					xtype: 'toolbar',
					dock: 'top',
					width: 508,
					items: [
						{
							xtype: 'button',
							text: 'New',
							listeners: {
								click: {
									fn: me.onButtonClick,
									scope: me
								}
							}
						},
						{
							xtype: 'button',
							text: 'Delete',
							listeners: {
								click: {
									fn: me.onButtonClick1,
									scope: me
								}
							}
						}
					]
				}
			],
			listeners: {
				beforeitemdblclick: {
					fn: me.onGridpanelBeforeItemDblClick,
					scope: me
				}
			}
		});

		me.callParent(arguments);
	},

	onGriddragdroppluginBeforeDrop: function(node, data, overModel, dropPosition, dropFunction, options) {
		console.info('Before drop.', this, node, data, overModel, dropPosition, dropFunction, options);
		/* NOTE
		Returning false to this event signals that the drop gesture was invalid, and if the drag proxy will
		animate back to the point from which the drag began.
		Returning 0 To this event signals that the data transfer operation should not take place, but that
		the gesture was valid, and that the repair operation should not take place.
		*/


		if('C.model.'+data.records[0].get('nodeType')==this.store.model.modelName){
			var record = node.dragData.records[0];
			var index = Ext.getStore(record.raw.nodeStoreId).findExact('_id', record.raw.nodeId);
			var node = Ext.getStore(record.raw.nodeStoreId).getAt(index);

			console.log(node);

			data.copy = true;
			this.store.add({
				'act_id': this.store.navigationNode.parentNode.data.id,
				'name': node.get('name'),
				'type': node.get('type'),
				'description': node.get('description'),
				'shiftable': node.get('shiftable'),
				'day_type': node.get('day_type'),
				'containsAppliances': node.get('containsAppliances'),
				'duration': node.get('duration'),
				'startTime': node.get('startTime'),
				'repeatsNrOfTime': node.get('repeatsNrOfTime')
			});
			dropFunction.cancelDrop();
			return 0;
		}
		return false;
	},

	onGriddragdroppluginDrop: function(node, data, overModel, dropPosition, options) {
		console.info('Drop.', this, node, data, overModel, dropPosition, options);
		/*var record = node.dragData.records[0];
		x = record;
		this.store.add({
		'project_id': this.store.navigationNode.parentNode.data.id,
		'name': record.get('name'),
		'description': record.get('description'),
		'editable': true
		});*/
	},

	onGridviewSelectionChange: function(dataview, selections, options) {
		if (selections[0]) {
			this.up('tabpanel').getTabPanel().loadRecord(selections[0]);
		}
	},

	onButtonClick: function(button, e, options) {
		console.info('Add clicked.', this, button, e, options);
		var act_id = this.store.navigationNode.parentNode.get('id');
		this.store.insert(0, new C.model.ActivityModel({act_id: act_id, containsAppliances:[]}));
		//this.plugins[0].startEdit(0, 0);
	},

	onButtonClick1: function(button, e, options) {
		console.info('Delete clicked.', this, button, e, options);

		var selection = this.getView().getSelectionModel().getSelection();
		if (selection) {
			this.store.remove(selection);	
		}
	},

	onGridpanelBeforeItemDblClick: function(tablepanel, record, item, index, e, options) {
		var myFormCmp = new C.view.ActivityModelsForm({});
		Ext.getCmp('MainTabPanel').add(myFormCmp);

		var gridStore = new C.store.ActmodAppliances();
		var grid = new C.view.ContainsAppliancesGrid({store: gridStore});
		myFormCmp.insert(1, grid);

		var durationGridStore = new C.store.DistributionInActivity();
		var durationDistrGrid = new C.view.DistributionInActivityGrid({store: durationGridStore, title: 'Distribution: duration'});
		myFormCmp.insert(2, durationDistrGrid);

		var startGridStore = new C.store.DistributionInActivity();
		var startDistrGrid = new C.view.DistributionInActivityGrid({store: startGridStore, title: 'Distribution: start time'});
		myFormCmp.insert(3, startDistrGrid);

		var repeatsGridStore = new C.store.DistributionInActivity();
		var repeatsDistrGrid = new C.view.DistributionInActivityGrid({store: repeatsGridStore, title: 'Distribution: repeats no of times'});
		myFormCmp.insert(4, repeatsDistrGrid);

		var myForm = myFormCmp.getForm();
		myForm.loadRecord(record);
		console.info(record);

		//Ext.getCmp('containsAppliancesGrid').store = new C.store.ActmodAppliances();
		//var gridStore = Ext.getCmp('containsAppliancesGrid').store;
		//var gridStore = Ext.getCmp('containsAppliancesGrid').getStore();
		//var gridStore = myFormCmp.query('grid')[0].getStore();

		//Ext.each(record.data.containsAppliances, function(index){
		curUrl = '/cassandra/api/app?actmod_id=' + record.data._id;

		Ext.Ajax.request({
			url: curUrl,
			method: 'GET',
			scope: this,
			success: function(response, opts) {
				var o = Ext.decode(response.responseText);
				gridStore.loadData(o.data, true);
			}
		});

		Ext.Ajax.request({
			url: '/cassandra/api/distr/' + record.data.duration,
			method: 'GET',
			scope: this,
			success: function(response, opts) {
				var o = Ext.decode(response.responseText);
				durationGridStore.loadData(o.data, true);
			}
		});

		Ext.Ajax.request({
			url: '/cassandra/api/distr/' + record.data.startTime,
			method: 'GET',
			scope: this,
			success: function(response, opts) {
				var o = Ext.decode(response.responseText);
				startGridStore.loadData(o.data, true);
			}
		});

		Ext.Ajax.request({
			url: '/cassandra/api/distr/' + record.data.repeatsNrOfTime,
			method: 'GET',
			scope: this,
			success: function(response, opts) {
				var o = Ext.decode(response.responseText);
				repeatsGridStore.loadData(o.data, true);
			}
		});


		//});






	}

});